/*
 * Copyright (c) 2021 - for information on the respective copyright owner
 * see the NOTICE file and/or the repository https://github.com/carbynestack/ephemeral.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package io.carbynestack.ephemeral.client;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import io.vavr.concurrent.Future;
import io.vavr.control.Either;
import io.vavr.control.Option;
import java.net.URI;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockedConstruction;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class EphemeralMultiClientTest {

  private static final String APPLICATION = "app";
  private static final String CODE = "a = sint(1)";
  private final ArgumentCaptor<Activation> activationArgumentCaptor =
      ArgumentCaptor.forClass(Activation.class);
  private final List<UUID> inputObjects = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
  private final String[] inputSecretIdArray =
      inputObjects.stream().map(UUID::toString).toArray(String[]::new);
  private final Activation activation =
      Activation.builder().code(CODE).amphoraParams(inputSecretIdArray).build();

  @Mock private EphemeralClient client1Mock;

  @Mock private EphemeralClient client2Mock;

  private EphemeralMultiClient client;

  @BeforeEach
  public void setUp() {
    client = new EphemeralMultiClient(Arrays.asList(client1Mock, client2Mock));
  }

  @Test
  void givenServiceUrlsIsNull_whenCreateClient_thenThrowException() {
    EphemeralMultiClient.Builder builder = new EphemeralMultiClient.Builder();
    assertThatThrownBy(() -> builder.withEndpoints(null))
        .isExactlyInstanceOf(NullPointerException.class)
        .hasMessageContaining("is null");
  }

  @Test
  void givenSuccessful_whenExecuteProgram_thenReturnResult() {
    ActivationResult result = new ActivationResult(Collections.singletonList(UUID.randomUUID()));
    when(client1Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.right(result)));
    when(client2Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.right(result)));
    Future<Either<ActivationError, List<ActivationResult>>> results =
        client.execute(activation.getCode(), inputObjects);
    results.await();
    assertThat(results.get().get()).isEqualTo(Arrays.asList(result, result));
    verify(client1Mock, times(1)).execute(activationArgumentCaptor.capture());
    Activation capturedActivation = activationArgumentCaptor.getValue();
    assertThat(capturedActivation.getCode()).isEqualTo(CODE);
    assertThat(capturedActivation.getGameId())
        .as("GameId must me autogenerated (not null).")
        .isNotNull();
    assertThat(capturedActivation.getAmphoraParams()).isEqualTo(inputSecretIdArray);
    verify(client2Mock, times(1)).execute(capturedActivation);
  }

  @Test
  void givenServiceRespondsUnsuccessful_whenExecuteProgram_thenReturnFailureCode() {
    int httpFailureCode = 404;
    String errMessage = "an unexpected error";
    ActivationError activationError =
        new ActivationError().setMessage(errMessage).setResponseCode(httpFailureCode);
    when(client1Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.left(activationError)));
    when(client2Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.left(activationError)));
    Future<Either<ActivationError, List<ActivationResult>>> results =
        client.execute(activation.getCode(), inputObjects);
    results.await();
    assertThat(results.get().getLeft().responseCode).isEqualTo(httpFailureCode);
    assertThat(results.get().getLeft().message).isEqualTo(errMessage);
    verify(client1Mock, times(1)).execute(any(Activation.class));
    verify(client2Mock, times(1)).execute(any(Activation.class));
  }

  @Test
  void givenServiceCommunicationFails_whenExecuteProgram_thenFutureFails() {
    Exception failure = new Exception("an unexpected error");
    when(client1Mock.execute(any(Activation.class))).thenReturn(Future.failed(failure));
    when(client2Mock.execute(any(Activation.class))).thenReturn(Future.failed(failure));
    Future<Either<ActivationError, List<ActivationResult>>> results =
        client.execute(activation.getCode(), inputObjects);
    results.await();
    assertThat(results.isFailure()).isTrue();
    verify(client1Mock, times(1)).execute(any(Activation.class));
    verify(client2Mock, times(1)).execute(any(Activation.class));
  }

  @Test
  void givenBearerTokenProvider_whenCreateClient_thenCorrectBearerTokensAreUsed() throws Exception {
    String token = RandomStringUtils.randomAlphanumeric(20);
    EphemeralEndpoint endpoint = new EphemeralEndpoint(new URI("https://example.com"), APPLICATION);
    try (MockedConstruction<EphemeralClient> mc =
        mockConstruction(
            EphemeralClient.class,
            (mock, context) ->
                assertThat(context.arguments().get(3)).isEqualTo(Option.some(token)))) {
      new EphemeralMultiClient.Builder()
          .withEndpoints(Arrays.asList(endpoint, endpoint))
          .withBearerTokenProvider(e -> token)
          .build();
      assertThat(mc.constructed().size()).isEqualTo(2);
    }
  }
}
